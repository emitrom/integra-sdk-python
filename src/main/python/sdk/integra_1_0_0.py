#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Feb 17 12:32:02 2015 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-o', 'integrads.py')
#
# Command line arguments:
#   integra.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "integrads.py" integra.xsd
#
# Current working directory (os.getcwd()):
#   sdk
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_


Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class abstractResultsPageable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pageSize=None, totalPages=None, totalRecords=None, currentPageTotal=None, currentPage=None, extensiontype_=None):
        self.original_tagname_ = None
        self.pageSize = pageSize
        self.totalPages = totalPages
        self.totalRecords = totalRecords
        self.currentPageTotal = currentPageTotal
        self.currentPage = currentPage
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstractResultsPageable.subclass:
            return abstractResultsPageable.subclass(*args_, **kwargs_)
        else:
            return abstractResultsPageable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pageSize(self): return self.pageSize
    def set_pageSize(self, pageSize): self.pageSize = pageSize
    def get_totalPages(self): return self.totalPages
    def set_totalPages(self, totalPages): self.totalPages = totalPages
    def get_totalRecords(self): return self.totalRecords
    def set_totalRecords(self, totalRecords): self.totalRecords = totalRecords
    def get_currentPageTotal(self): return self.currentPageTotal
    def set_currentPageTotal(self, currentPageTotal): self.currentPageTotal = currentPageTotal
    def get_currentPage(self): return self.currentPage
    def set_currentPage(self, currentPage): self.currentPage = currentPage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.pageSize is not None or
            self.totalPages is not None or
            self.totalRecords is not None or
            self.currentPageTotal is not None or
            self.currentPage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='abstractResultsPageable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractResultsPageable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='abstractResultsPageable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='abstractResultsPageable'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='abstractResultsPageable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pageSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spageSize>%s</%spageSize>%s' % (namespace_, self.gds_format_integer(self.pageSize, input_name='pageSize'), namespace_, eol_))
        if self.totalPages is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalPages>%s</%stotalPages>%s' % (namespace_, self.gds_format_integer(self.totalPages, input_name='totalPages'), namespace_, eol_))
        if self.totalRecords is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalRecords>%s</%stotalRecords>%s' % (namespace_, self.gds_format_integer(self.totalRecords, input_name='totalRecords'), namespace_, eol_))
        if self.currentPageTotal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentPageTotal>%s</%scurrentPageTotal>%s' % (namespace_, self.gds_format_integer(self.currentPageTotal, input_name='currentPageTotal'), namespace_, eol_))
        if self.currentPage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentPage>%s</%scurrentPage>%s' % (namespace_, self.gds_format_integer(self.currentPage, input_name='currentPage'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='abstractResultsPageable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pageSize is not None:
            showIndent(outfile, level)
            outfile.write('pageSize=%d,\n' % self.pageSize)
        if self.totalPages is not None:
            showIndent(outfile, level)
            outfile.write('totalPages=%d,\n' % self.totalPages)
        if self.totalRecords is not None:
            showIndent(outfile, level)
            outfile.write('totalRecords=%d,\n' % self.totalRecords)
        if self.currentPageTotal is not None:
            showIndent(outfile, level)
            outfile.write('currentPageTotal=%d,\n' % self.currentPageTotal)
        if self.currentPage is not None:
            showIndent(outfile, level)
            outfile.write('currentPage=%d,\n' % self.currentPage)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pageSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pageSize')
            self.pageSize = ival_
        elif nodeName_ == 'totalPages':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalPages')
            self.totalPages = ival_
        elif nodeName_ == 'totalRecords':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalRecords')
            self.totalRecords = ival_
        elif nodeName_ == 'currentPageTotal':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'currentPageTotal')
            self.currentPageTotal = ival_
        elif nodeName_ == 'currentPage':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'currentPage')
            self.currentPage = ival_
# end class abstractResultsPageable


class configuration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, license=None, id=None):
        self.original_tagname_ = None
        self.license = license
        self.id = id
    def factory(*args_, **kwargs_):
        if configuration.subclass:
            return configuration.subclass(*args_, **kwargs_)
        else:
            return configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_license(self): return self.license
    def set_license(self, license): self.license = license
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.license is not None or
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='configuration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='configuration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.license is not None:
            self.license.export(outfile, level, namespace_, name_='license', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='configuration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.license is not None:
            showIndent(outfile, level)
            outfile.write('license=model_.license(\n')
            self.license.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'license':
            obj_ = license.factory()
            obj_.build(child_)
            self.license = obj_
            obj_.original_tagname_ = 'license'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
# end class configuration


class configurations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, configuration=None):
        self.original_tagname_ = None
        if configuration is None:
            self.configuration = []
        else:
            self.configuration = configuration
    def factory(*args_, **kwargs_):
        if configurations.subclass:
            return configurations.subclass(*args_, **kwargs_)
        else:
            return configurations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def add_configuration(self, value): self.configuration.append(value)
    def insert_configuration_at(self, index, value): self.configuration.insert(index, value)
    def replace_configuration_at(self, index, value): self.configuration[index] = value
    def hasContent_(self):
        if (
            self.configuration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='configurations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configurations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='configurations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='configurations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='configurations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for configuration_ in self.configuration:
            configuration_.export(outfile, level, namespace_, name_='configuration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='configurations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('configuration=[\n')
        level += 1
        for configuration_ in self.configuration:
            showIndent(outfile, level)
            outfile.write('model_.configuration(\n')
            configuration_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configuration':
            obj_ = configuration.factory()
            obj_.build(child_)
            self.configuration.append(obj_)
            obj_.original_tagname_ = 'configuration'
# end class configurations


class entityPageRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, direction=None, pageSize=None, page=None):
        self.original_tagname_ = None
        self.direction = direction
        self.pageSize = pageSize
        self.page = page
    def factory(*args_, **kwargs_):
        if entityPageRequest.subclass:
            return entityPageRequest.subclass(*args_, **kwargs_)
        else:
            return entityPageRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_pageSize(self): return self.pageSize
    def set_pageSize(self, pageSize): self.pageSize = pageSize
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def hasContent_(self):
        if (
            self.direction is not None or
            self.pageSize is not None or
            self.page is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entityPageRequest', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entityPageRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='entityPageRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entityPageRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='entityPageRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.direction).encode(ExternalEncoding), input_name='direction'), namespace_, eol_))
        if self.pageSize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spageSize>%s</%spageSize>%s' % (namespace_, self.gds_format_integer(self.pageSize, input_name='pageSize'), namespace_, eol_))
        if self.page is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spage>%s</%spage>%s' % (namespace_, self.gds_format_integer(self.page, input_name='page'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='entityPageRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%s,\n' % quote_python(self.direction).encode(ExternalEncoding))
        if self.pageSize is not None:
            showIndent(outfile, level)
            outfile.write('pageSize=%d,\n' % self.pageSize)
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % self.page)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
        elif nodeName_ == 'pageSize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pageSize')
            self.pageSize = ival_
        elif nodeName_ == 'page':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'page')
            self.page = ival_
# end class entityPageRequest


class license(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, license=None, expiration=None, id=None, providers=None):
        self.original_tagname_ = None
        self.license = license
        if isinstance(expiration, basestring):
            initvalue_ = datetime_.datetime.strptime(expiration, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiration
        self.expiration = initvalue_
        self.id = id
        self.providers = providers
    def factory(*args_, **kwargs_):
        if license.subclass:
            return license.subclass(*args_, **kwargs_)
        else:
            return license(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_license(self): return self.license
    def set_license(self, license): self.license = license
    def get_expiration(self): return self.expiration
    def set_expiration(self, expiration): self.expiration = expiration
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_providers(self): return self.providers
    def set_providers(self, providers): self.providers = providers
    def hasContent_(self):
        if (
            self.license is not None or
            self.expiration is not None or
            self.id is not None or
            self.providers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='license', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='license')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='license', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='license'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='license', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.license is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slicense>%s</%slicense>%s' % (namespace_, self.gds_format_string(quote_xml(self.license).encode(ExternalEncoding), input_name='license'), namespace_, eol_))
        if self.expiration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiration>%s</%sexpiration>%s' % (namespace_, self.gds_format_datetime(self.expiration, input_name='expiration'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.providers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproviders>%s</%sproviders>%s' % (namespace_, self.gds_format_integer(self.providers, input_name='providers'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='license'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.license is not None:
            showIndent(outfile, level)
            outfile.write('license=%s,\n' % quote_python(self.license).encode(ExternalEncoding))
        if self.expiration is not None:
            showIndent(outfile, level)
            outfile.write('expiration=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.expiration, input_name='expiration'))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.providers is not None:
            showIndent(outfile, level)
            outfile.write('providers=%d,\n' % self.providers)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'license':
            license_ = child_.text
            license_ = self.gds_validate_string(license_, node, 'license')
            self.license = license_
        elif nodeName_ == 'expiration':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.expiration = dval_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'providers':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'providers')
            self.providers = ival_
# end class license


class provider(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port=None, id=None, reachable=None, hostname=None, timeout=None, password=None, name=None, username=None, secured=None, tags=None, description=None):
        self.original_tagname_ = None
        self.port = port
        self.id = id
        self.reachable = reachable
        self.hostname = hostname
        self.timeout = timeout
        self.password = password
        self.name = name
        self.username = username
        self.secured = secured
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
        self.description = description
    def factory(*args_, **kwargs_):
        if provider.subclass:
            return provider.subclass(*args_, **kwargs_)
        else:
            return provider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_reachable(self): return self.reachable
    def set_reachable(self, reachable): self.reachable = reachable
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_username(self): return self.username
    def set_username(self, username): self.username = username
    def get_secured(self): return self.secured
    def set_secured(self, secured): self.secured = secured
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags_at(self, index, value): self.tags.insert(index, value)
    def replace_tags_at(self, index, value): self.tags[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.port is not None or
            self.id is not None or
            self.reachable is not None or
            self.hostname is not None or
            self.timeout is not None or
            self.password is not None or
            self.name is not None or
            self.username is not None or
            self.secured is not None or
            self.tags or
            self.description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='provider', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='provider'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='provider', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_integer(self.port, input_name='port'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.reachable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreachable>%s</%sreachable>%s' % (namespace_, self.gds_format_boolean(self.reachable, input_name='reachable'), namespace_, eol_))
        if self.hostname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shostname>%s</%shostname>%s' % (namespace_, self.gds_format_string(quote_xml(self.hostname).encode(ExternalEncoding), input_name='hostname'), namespace_, eol_))
        if self.timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimeout>%s</%stimeout>%s' % (namespace_, self.gds_format_integer(self.timeout, input_name='timeout'), namespace_, eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.password).encode(ExternalEncoding), input_name='password'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespace_, self.gds_format_string(quote_xml(self.username).encode(ExternalEncoding), input_name='username'), namespace_, eol_))
        if self.secured is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecured>%s</%ssecured>%s' % (namespace_, self.gds_format_boolean(self.secured, input_name='secured'), namespace_, eol_))
        for tags_ in self.tags:
            tags_.export(outfile, level, namespace_, name_='tags', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='provider'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.reachable is not None:
            showIndent(outfile, level)
            outfile.write('reachable=%s,\n' % self.reachable)
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('hostname=%s,\n' % quote_python(self.hostname).encode(ExternalEncoding))
        if self.timeout is not None:
            showIndent(outfile, level)
            outfile.write('timeout=%d,\n' % self.timeout)
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % quote_python(self.password).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.username is not None:
            showIndent(outfile, level)
            outfile.write('username=%s,\n' % quote_python(self.username).encode(ExternalEncoding))
        if self.secured is not None:
            showIndent(outfile, level)
            outfile.write('secured=%s,\n' % self.secured)
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('model_.providerTag(\n')
            tags_.exportLiteral(outfile, level, name_='providerTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'reachable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'reachable')
            self.reachable = ival_
        elif nodeName_ == 'hostname':
            hostname_ = child_.text
            hostname_ = self.gds_validate_string(hostname_, node, 'hostname')
            self.hostname = hostname_
        elif nodeName_ == 'timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'timeout')
            self.timeout = ival_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'secured':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'secured')
            self.secured = ival_
        elif nodeName_ == 'tags':
            obj_ = providerTag.factory()
            obj_.build(child_)
            self.tags.append(obj_)
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
# end class provider


class providerAction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, pipes=None, id=None, displayName=None, output=None, name=None, input=None):
        self.original_tagname_ = None
        self.description = description
        if pipes is None:
            self.pipes = []
        else:
            self.pipes = pipes
        self.id = id
        self.displayName = displayName
        if output is None:
            self.output = []
        else:
            self.output = output
        self.name = name
        if input is None:
            self.input = []
        else:
            self.input = input
    def factory(*args_, **kwargs_):
        if providerAction.subclass:
            return providerAction.subclass(*args_, **kwargs_)
        else:
            return providerAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_pipes(self): return self.pipes
    def set_pipes(self, pipes): self.pipes = pipes
    def add_pipes(self, value): self.pipes.append(value)
    def insert_pipes_at(self, index, value): self.pipes.insert(index, value)
    def replace_pipes_at(self, index, value): self.pipes[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_output(self): return self.output
    def set_output(self, output): self.output = output
    def add_output(self, value): self.output.append(value)
    def insert_output_at(self, index, value): self.output.insert(index, value)
    def replace_output_at(self, index, value): self.output[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_input(self): return self.input
    def set_input(self, input): self.input = input
    def add_input(self, value): self.input.append(value)
    def insert_input_at(self, index, value): self.input.insert(index, value)
    def replace_input_at(self, index, value): self.input[index] = value
    def hasContent_(self):
        if (
            self.description is not None or
            self.pipes or
            self.id is not None or
            self.displayName is not None or
            self.output or
            self.name is not None or
            self.input
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerAction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerAction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerAction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerAction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        for pipes_ in self.pipes:
            pipes_.export(outfile, level, namespace_, name_='pipes', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_, eol_))
        for output_ in self.output:
            output_.export(outfile, level, namespace_, name_='output', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for input_ in self.input:
            input_.export(outfile, level, namespace_, name_='input', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='providerAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('pipes=[\n')
        level += 1
        for pipes_ in self.pipes:
            showIndent(outfile, level)
            outfile.write('model_.providerInput(\n')
            pipes_.exportLiteral(outfile, level, name_='providerInput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('output=[\n')
        level += 1
        for output_ in self.output:
            showIndent(outfile, level)
            outfile.write('model_.providerOutput(\n')
            output_.exportLiteral(outfile, level, name_='providerOutput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('input=[\n')
        level += 1
        for input_ in self.input:
            showIndent(outfile, level)
            outfile.write('model_.providerInput(\n')
            input_.exportLiteral(outfile, level, name_='providerInput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'pipes':
            obj_ = providerInput.factory()
            obj_.build(child_)
            self.pipes.append(obj_)
            obj_.original_tagname_ = 'pipes'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'output':
            obj_ = providerOutput.factory()
            obj_.build(child_)
            self.output.append(obj_)
            obj_.original_tagname_ = 'output'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'input':
            obj_ = providerInput.factory()
            obj_.build(child_)
            self.input.append(obj_)
            obj_.original_tagname_ = 'input'
# end class providerAction


class providerActions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, providerAction=None):
        self.original_tagname_ = None
        if providerAction is None:
            self.providerAction = []
        else:
            self.providerAction = providerAction
    def factory(*args_, **kwargs_):
        if providerActions.subclass:
            return providerActions.subclass(*args_, **kwargs_)
        else:
            return providerActions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_providerAction(self): return self.providerAction
    def set_providerAction(self, providerAction): self.providerAction = providerAction
    def add_providerAction(self, value): self.providerAction.append(value)
    def insert_providerAction_at(self, index, value): self.providerAction.insert(index, value)
    def replace_providerAction_at(self, index, value): self.providerAction[index] = value
    def hasContent_(self):
        if (
            self.providerAction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerActions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerActions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerActions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerActions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerActions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for providerAction_ in self.providerAction:
            providerAction_.export(outfile, level, namespace_, name_='providerAction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='providerActions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('providerAction=[\n')
        level += 1
        for providerAction_ in self.providerAction:
            showIndent(outfile, level)
            outfile.write('model_.providerAction(\n')
            providerAction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'providerAction':
            obj_ = providerAction.factory()
            obj_.build(child_)
            self.providerAction.append(obj_)
            obj_.original_tagname_ = 'providerAction'
# end class providerActions


class providerInput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inputFields=None, id=None, description=None, index=None, name=None, displayName=None):
        self.original_tagname_ = None
        if inputFields is None:
            self.inputFields = []
        else:
            self.inputFields = inputFields
        self.id = id
        self.description = description
        self.index = index
        self.name = name
        self.displayName = displayName
    def factory(*args_, **kwargs_):
        if providerInput.subclass:
            return providerInput.subclass(*args_, **kwargs_)
        else:
            return providerInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inputFields(self): return self.inputFields
    def set_inputFields(self, inputFields): self.inputFields = inputFields
    def add_inputFields(self, value): self.inputFields.append(value)
    def insert_inputFields_at(self, index, value): self.inputFields.insert(index, value)
    def replace_inputFields_at(self, index, value): self.inputFields[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def hasContent_(self):
        if (
            self.inputFields or
            self.id is not None or
            self.description is not None or
            self.index is not None or
            self.name is not None or
            self.displayName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerInput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerInput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerInput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for inputFields_ in self.inputFields:
            inputFields_.export(outfile, level, namespace_, name_='inputFields', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespace_, self.gds_format_integer(self.index, input_name='index'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='providerInput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('inputFields=[\n')
        level += 1
        for inputFields_ in self.inputFields:
            showIndent(outfile, level)
            outfile.write('model_.providerInputField(\n')
            inputFields_.exportLiteral(outfile, level, name_='providerInputField')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inputFields':
            obj_ = providerInputField.factory()
            obj_.build(child_)
            self.inputFields.append(obj_)
            obj_.original_tagname_ = 'inputFields'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
# end class providerInput


class providerInputField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, index=None, description=None, name=None, dataType=None, id=None, required=None, displayName=None, value=None):
        self.original_tagname_ = None
        self.index = index
        self.description = description
        self.name = name
        self.dataType = dataType
        self.id = id
        self.required = required
        self.displayName = displayName
        self.value = value
    def factory(*args_, **kwargs_):
        if providerInputField.subclass:
            return providerInputField.subclass(*args_, **kwargs_)
        else:
            return providerInputField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.index is not None or
            self.description is not None or
            self.name is not None or
            self.dataType is not None or
            self.id is not None or
            self.required is not None or
            self.displayName is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerInputField', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerInputField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerInputField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerInputField'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerInputField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespace_, self.gds_format_integer(self.index, input_name='index'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.dataType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdataType>%s</%sdataType>%s' % (namespace_, self.gds_format_string(quote_xml(self.dataType).encode(ExternalEncoding), input_name='dataType'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.required is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequired>%s</%srequired>%s' % (namespace_, self.gds_format_boolean(self.required, input_name='required'), namespace_, eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='providerInputField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=%d,\n' % self.index)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.dataType is not None:
            showIndent(outfile, level)
            outfile.write('dataType=%s,\n' % quote_python(self.dataType).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.required is not None:
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % self.required)
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'index':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'dataType':
            dataType_ = child_.text
            dataType_ = self.gds_validate_string(dataType_, node, 'dataType')
            self.dataType = dataType_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'required':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'required')
            self.required = ival_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class providerInputField


class providerOutput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, outputFields=None, id=None, displayName=None):
        self.original_tagname_ = None
        self.description = description
        self.name = name
        if outputFields is None:
            self.outputFields = []
        else:
            self.outputFields = outputFields
        self.id = id
        self.displayName = displayName
    def factory(*args_, **kwargs_):
        if providerOutput.subclass:
            return providerOutput.subclass(*args_, **kwargs_)
        else:
            return providerOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_outputFields(self): return self.outputFields
    def set_outputFields(self, outputFields): self.outputFields = outputFields
    def add_outputFields(self, value): self.outputFields.append(value)
    def insert_outputFields_at(self, index, value): self.outputFields.insert(index, value)
    def replace_outputFields_at(self, index, value): self.outputFields[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def hasContent_(self):
        if (
            self.description is not None or
            self.name is not None or
            self.outputFields or
            self.id is not None or
            self.displayName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerOutput', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerOutput')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerOutput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for outputFields_ in self.outputFields:
            outputFields_.export(outfile, level, namespace_, name_='outputFields', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='providerOutput'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('outputFields=[\n')
        level += 1
        for outputFields_ in self.outputFields:
            showIndent(outfile, level)
            outfile.write('model_.providerOutputField(\n')
            outputFields_.exportLiteral(outfile, level, name_='providerOutputField')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'outputFields':
            obj_ = providerOutputField.factory()
            obj_.build(child_)
            self.outputFields.append(obj_)
            obj_.original_tagname_ = 'outputFields'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
# end class providerOutput


class providerOutputField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, id=None, value=None, displayName=None):
        self.original_tagname_ = None
        self.description = description
        self.name = name
        self.id = id
        self.value = value
        self.displayName = displayName
    def factory(*args_, **kwargs_):
        if providerOutputField.subclass:
            return providerOutputField.subclass(*args_, **kwargs_)
        else:
            return providerOutputField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def hasContent_(self):
        if (
            self.description is not None or
            self.name is not None or
            self.id is not None or
            self.value is not None or
            self.displayName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerOutputField', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerOutputField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerOutputField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerOutputField'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerOutputField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='providerOutputField'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
# end class providerOutputField


class providerOutputs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, providerOutputs=None):
        self.original_tagname_ = None
        if providerOutputs is None:
            self.providerOutputs = []
        else:
            self.providerOutputs = providerOutputs
    def factory(*args_, **kwargs_):
        if providerOutputs.subclass:
            return providerOutputs.subclass(*args_, **kwargs_)
        else:
            return providerOutputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_providerOutputs(self): return self.providerOutputs
    def set_providerOutputs(self, providerOutputs): self.providerOutputs = providerOutputs
    def add_providerOutputs(self, value): self.providerOutputs.append(value)
    def insert_providerOutputs_at(self, index, value): self.providerOutputs.insert(index, value)
    def replace_providerOutputs_at(self, index, value): self.providerOutputs[index] = value
    def hasContent_(self):
        if (
            self.providerOutputs
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerOutputs', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerOutputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerOutputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerOutputs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providerOutputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for providerOutputs_ in self.providerOutputs:
            providerOutputs_.export(outfile, level, namespace_, name_='providerOutputs', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='providerOutputs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('providerOutputs=[\n')
        level += 1
        for providerOutputs_ in self.providerOutputs:
            showIndent(outfile, level)
            outfile.write('model_.providerOutput(\n')
            providerOutputs_.exportLiteral(outfile, level, name_='providerOutput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'providerOutputs':
            obj_ = providerOutput.factory()
            obj_.build(child_)
            self.providerOutputs.append(obj_)
            obj_.original_tagname_ = 'providerOutputs'
# end class providerOutputs


class providers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, provider=None):
        self.original_tagname_ = None
        if provider is None:
            self.provider = []
        else:
            self.provider = provider
    def factory(*args_, **kwargs_):
        if providers.subclass:
            return providers.subclass(*args_, **kwargs_)
        else:
            return providers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provider(self): return self.provider
    def set_provider(self, provider): self.provider = provider
    def add_provider(self, value): self.provider.append(value)
    def insert_provider_at(self, index, value): self.provider.insert(index, value)
    def replace_provider_at(self, index, value): self.provider[index] = value
    def hasContent_(self):
        if (
            self.provider
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providers'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for provider_ in self.provider:
            provider_.export(outfile, level, namespace_, name_='provider', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='providers'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('provider=[\n')
        level += 1
        for provider_ in self.provider:
            showIndent(outfile, level)
            outfile.write('model_.provider(\n')
            provider_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'provider':
            obj_ = provider.factory()
            obj_.build(child_)
            self.provider.append(obj_)
            obj_.original_tagname_ = 'provider'
# end class providers


class schedules(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, schedule=None):
        self.original_tagname_ = None
        if schedule is None:
            self.schedule = []
        else:
            self.schedule = schedule
    def factory(*args_, **kwargs_):
        if schedules.subclass:
            return schedules.subclass(*args_, **kwargs_)
        else:
            return schedules(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def add_schedule(self, value): self.schedule.append(value)
    def insert_schedule_at(self, index, value): self.schedule.insert(index, value)
    def replace_schedule_at(self, index, value): self.schedule[index] = value
    def hasContent_(self):
        if (
            self.schedule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='schedules', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='schedules')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='schedules', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='schedules'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='schedules', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for schedule_ in self.schedule:
            schedule_.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='schedules'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('schedule=[\n')
        level += 1
        for schedule_ in self.schedule:
            showIndent(outfile, level)
            outfile.write('model_.schedule(\n')
            schedule_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'schedule':
            obj_ = schedule.factory()
            obj_.build(child_)
            self.schedule.append(obj_)
            obj_.original_tagname_ = 'schedule'
# end class schedules


class tag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.name = name
        self.id = id
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if tag.subclass:
            return tag.subclass(*args_, **kwargs_)
        else:
            return tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.name is not None or
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tag'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='tag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
# end class tag


class tags(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tag=None):
        self.original_tagname_ = None
        if tag is None:
            self.tag = []
        else:
            self.tag = tag
    def factory(*args_, **kwargs_):
        if tags.subclass:
            return tags.subclass(*args_, **kwargs_)
        else:
            return tags(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self): return self.tag
    def set_tag(self, tag): self.tag = tag
    def add_tag(self, value): self.tag.append(value)
    def insert_tag_at(self, index, value): self.tag.insert(index, value)
    def replace_tag_at(self, index, value): self.tag[index] = value
    def hasContent_(self):
        if (
            self.tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tags', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tags')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tags', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tags'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tags', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_ in self.tag:
            tag_.export(outfile, level, namespace_, name_='tag', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='tags'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('tag=[\n')
        level += 1
        for tag_ in self.tag:
            showIndent(outfile, level)
            outfile.write('model_.tag(\n')
            tag_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            class_obj_ = self.get_class_obj_(child_, tag)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.tag.append(obj_)
            obj_.original_tagname_ = 'tag'
# end class tags


class workflow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, onSuccessWorkflow=None, workflowSteps=None, onFailureWorkflow=None, tags=None, schedules=None, description=None, id=None, name=None):
        self.original_tagname_ = None
        self.onSuccessWorkflow = onSuccessWorkflow
        if workflowSteps is None:
            self.workflowSteps = []
        else:
            self.workflowSteps = workflowSteps
        self.onFailureWorkflow = onFailureWorkflow
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
        if schedules is None:
            self.schedules = []
        else:
            self.schedules = schedules
        self.description = description
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if workflow.subclass:
            return workflow.subclass(*args_, **kwargs_)
        else:
            return workflow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_onSuccessWorkflow(self): return self.onSuccessWorkflow
    def set_onSuccessWorkflow(self, onSuccessWorkflow): self.onSuccessWorkflow = onSuccessWorkflow
    def get_workflowSteps(self): return self.workflowSteps
    def set_workflowSteps(self, workflowSteps): self.workflowSteps = workflowSteps
    def add_workflowSteps(self, value): self.workflowSteps.append(value)
    def insert_workflowSteps_at(self, index, value): self.workflowSteps.insert(index, value)
    def replace_workflowSteps_at(self, index, value): self.workflowSteps[index] = value
    def get_onFailureWorkflow(self): return self.onFailureWorkflow
    def set_onFailureWorkflow(self, onFailureWorkflow): self.onFailureWorkflow = onFailureWorkflow
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags_at(self, index, value): self.tags.insert(index, value)
    def replace_tags_at(self, index, value): self.tags[index] = value
    def get_schedules(self): return self.schedules
    def set_schedules(self, schedules): self.schedules = schedules
    def add_schedules(self, value): self.schedules.append(value)
    def insert_schedules_at(self, index, value): self.schedules.insert(index, value)
    def replace_schedules_at(self, index, value): self.schedules[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.onSuccessWorkflow is not None or
            self.workflowSteps or
            self.onFailureWorkflow is not None or
            self.tags or
            self.schedules or
            self.description is not None or
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflow'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.onSuccessWorkflow is not None:
            self.onSuccessWorkflow.export(outfile, level, namespace_, name_='onSuccessWorkflow', pretty_print=pretty_print)
        for workflowSteps_ in self.workflowSteps:
            workflowSteps_.export(outfile, level, namespace_, name_='workflowSteps', pretty_print=pretty_print)
        if self.onFailureWorkflow is not None:
            self.onFailureWorkflow.export(outfile, level, namespace_, name_='onFailureWorkflow', pretty_print=pretty_print)
        for tags_ in self.tags:
            tags_.export(outfile, level, namespace_, name_='tags', pretty_print=pretty_print)
        for schedules_ in self.schedules:
            schedules_.export(outfile, level, namespace_, name_='schedules', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='workflow'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.onSuccessWorkflow is not None:
            showIndent(outfile, level)
            outfile.write('onSuccessWorkflow=model_.workflow(\n')
            self.onSuccessWorkflow.exportLiteral(outfile, level, name_='onSuccessWorkflow')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('workflowSteps=[\n')
        level += 1
        for workflowSteps_ in self.workflowSteps:
            showIndent(outfile, level)
            outfile.write('model_.workflowStep(\n')
            workflowSteps_.exportLiteral(outfile, level, name_='workflowStep')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.onFailureWorkflow is not None:
            showIndent(outfile, level)
            outfile.write('onFailureWorkflow=model_.workflow(\n')
            self.onFailureWorkflow.exportLiteral(outfile, level, name_='onFailureWorkflow')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('model_.workflowTag(\n')
            tags_.exportLiteral(outfile, level, name_='workflowTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('schedules=[\n')
        level += 1
        for schedules_ in self.schedules:
            showIndent(outfile, level)
            outfile.write('model_.schedule(\n')
            schedules_.exportLiteral(outfile, level, name_='schedule')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'onSuccessWorkflow':
            obj_ = workflow.factory()
            obj_.build(child_)
            self.onSuccessWorkflow = obj_
            obj_.original_tagname_ = 'onSuccessWorkflow'
        elif nodeName_ == 'workflowSteps':
            obj_ = workflowStep.factory()
            obj_.build(child_)
            self.workflowSteps.append(obj_)
            obj_.original_tagname_ = 'workflowSteps'
        elif nodeName_ == 'onFailureWorkflow':
            obj_ = workflow.factory()
            obj_.build(child_)
            self.onFailureWorkflow = obj_
            obj_.original_tagname_ = 'onFailureWorkflow'
        elif nodeName_ == 'tags':
            obj_ = workflowTag.factory()
            obj_.build(child_)
            self.tags.append(obj_)
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'schedules':
            obj_ = schedule.factory()
            obj_.build(child_)
            self.schedules.append(obj_)
            obj_.original_tagname_ = 'schedules'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class workflow


class workflowAction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, workflowTransaction=None, name=None, providerAction=None, id=None, provider=None, description=None, tags=None):
        self.original_tagname_ = None
        self.workflowTransaction = workflowTransaction
        self.name = name
        self.providerAction = providerAction
        self.id = id
        self.provider = provider
        self.description = description
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
    def factory(*args_, **kwargs_):
        if workflowAction.subclass:
            return workflowAction.subclass(*args_, **kwargs_)
        else:
            return workflowAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_workflowTransaction(self): return self.workflowTransaction
    def set_workflowTransaction(self, workflowTransaction): self.workflowTransaction = workflowTransaction
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_providerAction(self): return self.providerAction
    def set_providerAction(self, providerAction): self.providerAction = providerAction
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_provider(self): return self.provider
    def set_provider(self, provider): self.provider = provider
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags_at(self, index, value): self.tags.insert(index, value)
    def replace_tags_at(self, index, value): self.tags[index] = value
    def hasContent_(self):
        if (
            self.workflowTransaction is not None or
            self.name is not None or
            self.providerAction is not None or
            self.id is not None or
            self.provider is not None or
            self.description is not None or
            self.tags
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowAction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowAction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowAction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflowAction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.workflowTransaction is not None:
            self.workflowTransaction.export(outfile, level, namespace_, name_='workflowTransaction', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.providerAction is not None:
            self.providerAction.export(outfile, level, namespace_, name_='providerAction', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.provider is not None:
            self.provider.export(outfile, level, namespace_, name_='provider', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        for tags_ in self.tags:
            tags_.export(outfile, level, namespace_, name_='tags', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflowAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.workflowTransaction is not None:
            showIndent(outfile, level)
            outfile.write('workflowTransaction=model_.workflowTransaction(\n')
            self.workflowTransaction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.providerAction is not None:
            showIndent(outfile, level)
            outfile.write('providerAction=model_.providerAction(\n')
            self.providerAction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.provider is not None:
            showIndent(outfile, level)
            outfile.write('provider=model_.provider(\n')
            self.provider.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('model_.workflowActionTag(\n')
            tags_.exportLiteral(outfile, level, name_='workflowActionTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'workflowTransaction':
            obj_ = workflowTransaction.factory()
            obj_.build(child_)
            self.workflowTransaction = obj_
            obj_.original_tagname_ = 'workflowTransaction'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'providerAction':
            obj_ = providerAction.factory()
            obj_.build(child_)
            self.providerAction = obj_
            obj_.original_tagname_ = 'providerAction'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'provider':
            obj_ = provider.factory()
            obj_.build(child_)
            self.provider = obj_
            obj_.original_tagname_ = 'provider'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'tags':
            obj_ = workflowActionTag.factory()
            obj_.build(child_)
            self.tags.append(obj_)
            obj_.original_tagname_ = 'tags'
# end class workflowAction


class workflowActionSearch(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, name=None, tags=None):
        self.original_tagname_ = None
        self.description = description
        self.name = name
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
    def factory(*args_, **kwargs_):
        if workflowActionSearch.subclass:
            return workflowActionSearch.subclass(*args_, **kwargs_)
        else:
            return workflowActionSearch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags_at(self, index, value): self.tags.insert(index, value)
    def replace_tags_at(self, index, value): self.tags[index] = value
    def hasContent_(self):
        if (
            self.description is not None or
            self.name is not None or
            self.tags
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowActionSearch', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowActionSearch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowActionSearch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowActionSearch'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflowActionSearch', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        for tags_ in self.tags:
            tags_.export(outfile, level, namespace_, name_='tags', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflowActionSearch'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('model_.workflowActionTag(\n')
            tags_.exportLiteral(outfile, level, name_='workflowActionTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'tags':
            obj_ = workflowActionTag.factory()
            obj_.build(child_)
            self.tags.append(obj_)
            obj_.original_tagname_ = 'tags'
# end class workflowActionSearch


class workflowActionTag(tag):
    subclass = None
    superclass = tag
    def __init__(self, name=None, id=None):
        self.original_tagname_ = None
        super(workflowActionTag, self).__init__(name, id, )
    def factory(*args_, **kwargs_):
        if workflowActionTag.subclass:
            return workflowActionTag.subclass(*args_, **kwargs_)
        else:
            return workflowActionTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(workflowActionTag, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowActionTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowActionTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowActionTag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowActionTag'):
        super(workflowActionTag, self).exportAttributes(outfile, level, already_processed, namespace_, name_='workflowActionTag')
    def exportChildren(self, outfile, level, namespace_='', name_='workflowActionTag', fromsubclass_=False, pretty_print=True):
        super(workflowActionTag, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflowActionTag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(workflowActionTag, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(workflowActionTag, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(workflowActionTag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(workflowActionTag, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class workflowActionTag


class workflowActions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, workflowAction=None):
        self.original_tagname_ = None
        if workflowAction is None:
            self.workflowAction = []
        else:
            self.workflowAction = workflowAction
    def factory(*args_, **kwargs_):
        if workflowActions.subclass:
            return workflowActions.subclass(*args_, **kwargs_)
        else:
            return workflowActions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_workflowAction(self): return self.workflowAction
    def set_workflowAction(self, workflowAction): self.workflowAction = workflowAction
    def add_workflowAction(self, value): self.workflowAction.append(value)
    def insert_workflowAction_at(self, index, value): self.workflowAction.insert(index, value)
    def replace_workflowAction_at(self, index, value): self.workflowAction[index] = value
    def hasContent_(self):
        if (
            self.workflowAction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowActions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowActions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowActions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowActions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflowActions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for workflowAction_ in self.workflowAction:
            workflowAction_.export(outfile, level, namespace_, name_='workflowAction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflowActions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('workflowAction=[\n')
        level += 1
        for workflowAction_ in self.workflowAction:
            showIndent(outfile, level)
            outfile.write('model_.workflowAction(\n')
            workflowAction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'workflowAction':
            obj_ = workflowAction.factory()
            obj_.build(child_)
            self.workflowAction.append(obj_)
            obj_.original_tagname_ = 'workflowAction'
# end class workflowActions


class workflowStep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pipe=None, step=None, target=None, uuid=None, workflowAction=None, id=None):
        self.original_tagname_ = None
        self.pipe = pipe
        self.step = step
        if target is None:
            self.target = []
        else:
            self.target = target
        self.uuid = uuid
        self.workflowAction = workflowAction
        self.id = id
    def factory(*args_, **kwargs_):
        if workflowStep.subclass:
            return workflowStep.subclass(*args_, **kwargs_)
        else:
            return workflowStep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pipe(self): return self.pipe
    def set_pipe(self, pipe): self.pipe = pipe
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def add_target(self, value): self.target.append(value)
    def insert_target_at(self, index, value): self.target.insert(index, value)
    def replace_target_at(self, index, value): self.target[index] = value
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_workflowAction(self): return self.workflowAction
    def set_workflowAction(self, workflowAction): self.workflowAction = workflowAction
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.pipe is not None or
            self.step is not None or
            self.target or
            self.uuid is not None or
            self.workflowAction is not None or
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowStep', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowStep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflowStep', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pipe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spipe>%s</%spipe>%s' % (namespace_, self.gds_format_boolean(self.pipe, input_name='pipe'), namespace_, eol_))
        if self.step is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstep>%s</%sstep>%s' % (namespace_, self.gds_format_integer(self.step, input_name='step'), namespace_, eol_))
        for target_ in self.target:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespace_, self.gds_format_integer(target_, input_name='target'), namespace_, eol_))
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.workflowAction is not None:
            self.workflowAction.export(outfile, level, namespace_, name_='workflowAction', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='workflowStep'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pipe is not None:
            showIndent(outfile, level)
            outfile.write('pipe=%s,\n' % self.pipe)
        if self.step is not None:
            showIndent(outfile, level)
            outfile.write('step=%d,\n' % self.step)
        showIndent(outfile, level)
        outfile.write('target=[\n')
        level += 1
        for target_ in self.target:
            showIndent(outfile, level)
            outfile.write('%d,\n' % target_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.uuid is not None:
            showIndent(outfile, level)
            outfile.write('uuid=%s,\n' % quote_python(self.uuid).encode(ExternalEncoding))
        if self.workflowAction is not None:
            showIndent(outfile, level)
            outfile.write('workflowAction=model_.workflowAction(\n')
            self.workflowAction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pipe':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'pipe')
            self.pipe = ival_
        elif nodeName_ == 'step':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'step')
            self.step = ival_
        elif nodeName_ == 'target':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'target')
            self.target.append(ival_)
        elif nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'workflowAction':
            obj_ = workflowAction.factory()
            obj_.build(child_)
            self.workflowAction = obj_
            obj_.original_tagname_ = 'workflowAction'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
# end class workflowStep


class workflowTag(tag):
    subclass = None
    superclass = tag
    def __init__(self, name=None, id=None):
        self.original_tagname_ = None
        super(workflowTag, self).__init__(name, id, )
    def factory(*args_, **kwargs_):
        if workflowTag.subclass:
            return workflowTag.subclass(*args_, **kwargs_)
        else:
            return workflowTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(workflowTag, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowTag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowTag'):
        super(workflowTag, self).exportAttributes(outfile, level, already_processed, namespace_, name_='workflowTag')
    def exportChildren(self, outfile, level, namespace_='', name_='workflowTag', fromsubclass_=False, pretty_print=True):
        super(workflowTag, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflowTag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(workflowTag, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(workflowTag, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(workflowTag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(workflowTag, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class workflowTag


class workflowTransaction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scheduleId=None, workflowId=None, id=None, license=None):
        self.original_tagname_ = None
        self.scheduleId = scheduleId
        self.workflowId = workflowId
        self.id = id
        self.license = license
    def factory(*args_, **kwargs_):
        if workflowTransaction.subclass:
            return workflowTransaction.subclass(*args_, **kwargs_)
        else:
            return workflowTransaction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduleId(self): return self.scheduleId
    def set_scheduleId(self, scheduleId): self.scheduleId = scheduleId
    def get_workflowId(self): return self.workflowId
    def set_workflowId(self, workflowId): self.workflowId = workflowId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_license(self): return self.license
    def set_license(self, license): self.license = license
    def hasContent_(self):
        if (
            self.scheduleId is not None or
            self.workflowId is not None or
            self.id is not None or
            self.license is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflowTransaction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflowTransaction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflowTransaction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflowTransaction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflowTransaction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scheduleId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscheduleId>%s</%sscheduleId>%s' % (namespace_, self.gds_format_integer(self.scheduleId, input_name='scheduleId'), namespace_, eol_))
        if self.workflowId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sworkflowId>%s</%sworkflowId>%s' % (namespace_, self.gds_format_integer(self.workflowId, input_name='workflowId'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        if self.license is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slicense>%s</%slicense>%s' % (namespace_, self.gds_format_string(quote_xml(self.license).encode(ExternalEncoding), input_name='license'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='workflowTransaction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scheduleId is not None:
            showIndent(outfile, level)
            outfile.write('scheduleId=%d,\n' % self.scheduleId)
        if self.workflowId is not None:
            showIndent(outfile, level)
            outfile.write('workflowId=%d,\n' % self.workflowId)
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id).encode(ExternalEncoding))
        if self.license is not None:
            showIndent(outfile, level)
            outfile.write('license=%s,\n' % quote_python(self.license).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduleId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'scheduleId')
            self.scheduleId = ival_
        elif nodeName_ == 'workflowId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'workflowId')
            self.workflowId = ival_
        elif nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'license':
            license_ = child_.text
            license_ = self.gds_validate_string(license_, node, 'license')
            self.license = license_
# end class workflowTransaction


class workflows(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, workflow=None):
        self.original_tagname_ = None
        if workflow is None:
            self.workflow = []
        else:
            self.workflow = workflow
    def factory(*args_, **kwargs_):
        if workflows.subclass:
            return workflows.subclass(*args_, **kwargs_)
        else:
            return workflows(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_workflow(self): return self.workflow
    def set_workflow(self, workflow): self.workflow = workflow
    def add_workflow(self, value): self.workflow.append(value)
    def insert_workflow_at(self, index, value): self.workflow.insert(index, value)
    def replace_workflow_at(self, index, value): self.workflow[index] = value
    def hasContent_(self):
        if (
            self.workflow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='workflows', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='workflows')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='workflows', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='workflows'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='workflows', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for workflow_ in self.workflow:
            workflow_.export(outfile, level, namespace_, name_='workflow', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='workflows'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('workflow=[\n')
        level += 1
        for workflow_ in self.workflow:
            showIndent(outfile, level)
            outfile.write('model_.workflow(\n')
            workflow_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'workflow':
            obj_ = workflow.factory()
            obj_.build(child_)
            self.workflow.append(obj_)
            obj_.original_tagname_ = 'workflow'
# end class workflows


class schedule(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, workflows=None, tasks=None, name=None, enabled=None, priority=None, tags=None, id=None):
        self.original_tagname_ = None
        self.description = description
        if workflows is None:
            self.workflows = []
        else:
            self.workflows = workflows
        if tasks is None:
            self.tasks = []
        else:
            self.tasks = tasks
        self.name = name
        self.enabled = enabled
        self.priority = priority
        if tags is None:
            self.tags = []
        else:
            self.tags = tags
        self.id = id
    def factory(*args_, **kwargs_):
        if schedule.subclass:
            return schedule.subclass(*args_, **kwargs_)
        else:
            return schedule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_workflows(self): return self.workflows
    def set_workflows(self, workflows): self.workflows = workflows
    def add_workflows(self, value): self.workflows.append(value)
    def insert_workflows_at(self, index, value): self.workflows.insert(index, value)
    def replace_workflows_at(self, index, value): self.workflows[index] = value
    def get_tasks(self): return self.tasks
    def set_tasks(self, tasks): self.tasks = tasks
    def add_tasks(self, value): self.tasks.append(value)
    def insert_tasks_at(self, index, value): self.tasks.insert(index, value)
    def replace_tasks_at(self, index, value): self.tasks[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def add_tags(self, value): self.tags.append(value)
    def insert_tags_at(self, index, value): self.tags.insert(index, value)
    def replace_tags_at(self, index, value): self.tags[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.description is not None or
            self.workflows or
            self.tasks or
            self.name is not None or
            self.enabled is not None or
            self.priority is not None or
            self.tags or
            self.id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='schedule', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='schedule')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='schedule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='schedule'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='schedule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        for workflows_ in self.workflows:
            workflows_.export(outfile, level, namespace_, name_='workflows', pretty_print=pretty_print)
        for tasks_ in self.tasks:
            tasks_.export(outfile, level, namespace_, name_='tasks', pretty_print=pretty_print)
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespace_, self.gds_format_boolean(self.enabled, input_name='enabled'), namespace_, eol_))
        if self.priority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriority>%s</%spriority>%s' % (namespace_, self.gds_format_integer(self.priority, input_name='priority'), namespace_, eol_))
        for tags_ in self.tags:
            tags_.export(outfile, level, namespace_, name_='tags', pretty_print=pretty_print)
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='schedule'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('workflows=[\n')
        level += 1
        for workflows_ in self.workflows:
            showIndent(outfile, level)
            outfile.write('model_.workflow(\n')
            workflows_.exportLiteral(outfile, level, name_='workflow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tasks=[\n')
        level += 1
        for tasks_ in self.tasks:
            showIndent(outfile, level)
            outfile.write('model_.task(\n')
            tasks_.exportLiteral(outfile, level, name_='task')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=%s,\n' % self.enabled)
        if self.priority is not None:
            showIndent(outfile, level)
            outfile.write('priority=%d,\n' % self.priority)
        showIndent(outfile, level)
        outfile.write('tags=[\n')
        level += 1
        for tags_ in self.tags:
            showIndent(outfile, level)
            outfile.write('model_.scheduleTag(\n')
            tags_.exportLiteral(outfile, level, name_='scheduleTag')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'workflows':
            obj_ = workflow.factory()
            obj_.build(child_)
            self.workflows.append(obj_)
            obj_.original_tagname_ = 'workflows'
        elif nodeName_ == 'tasks':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <tasks> element')
            self.tasks.append(obj_)
            obj_.original_tagname_ = 'tasks'
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'priority':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'priority')
            self.priority = ival_
        elif nodeName_ == 'tags':
            obj_ = scheduleTag.factory()
            obj_.build(child_)
            self.tags.append(obj_)
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
# end class schedule


class scheduleResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transactionId=None, workflow=None, schedule=None, startedAt=None, id=None, endedAt=None, outputs=None, scheduleResultStatus=None):
        self.original_tagname_ = None
        self.transactionId = transactionId
        self.workflow = workflow
        self.schedule = schedule
        if isinstance(startedAt, basestring):
            initvalue_ = datetime_.datetime.strptime(startedAt, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startedAt
        self.startedAt = initvalue_
        self.id = id
        if isinstance(endedAt, basestring):
            initvalue_ = datetime_.datetime.strptime(endedAt, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endedAt
        self.endedAt = initvalue_
        if outputs is None:
            self.outputs = []
        else:
            self.outputs = outputs
        self.scheduleResultStatus = scheduleResultStatus
    def factory(*args_, **kwargs_):
        if scheduleResult.subclass:
            return scheduleResult.subclass(*args_, **kwargs_)
        else:
            return scheduleResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transactionId(self): return self.transactionId
    def set_transactionId(self, transactionId): self.transactionId = transactionId
    def get_workflow(self): return self.workflow
    def set_workflow(self, workflow): self.workflow = workflow
    def get_schedule(self): return self.schedule
    def set_schedule(self, schedule): self.schedule = schedule
    def get_startedAt(self): return self.startedAt
    def set_startedAt(self, startedAt): self.startedAt = startedAt
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_endedAt(self): return self.endedAt
    def set_endedAt(self, endedAt): self.endedAt = endedAt
    def get_outputs(self): return self.outputs
    def set_outputs(self, outputs): self.outputs = outputs
    def add_outputs(self, value): self.outputs.append(value)
    def insert_outputs_at(self, index, value): self.outputs.insert(index, value)
    def replace_outputs_at(self, index, value): self.outputs[index] = value
    def get_scheduleResultStatus(self): return self.scheduleResultStatus
    def set_scheduleResultStatus(self, scheduleResultStatus): self.scheduleResultStatus = scheduleResultStatus
    def hasContent_(self):
        if (
            self.transactionId is not None or
            self.workflow is not None or
            self.schedule is not None or
            self.startedAt is not None or
            self.id is not None or
            self.endedAt is not None or
            self.outputs or
            self.scheduleResultStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='scheduleResult', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='scheduleResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scheduleResult'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scheduleResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransactionId>%s</%stransactionId>%s' % (namespace_, self.gds_format_string(quote_xml(self.transactionId).encode(ExternalEncoding), input_name='transactionId'), namespace_, eol_))
        if self.workflow is not None:
            self.workflow.export(outfile, level, namespace_, name_='workflow', pretty_print=pretty_print)
        if self.schedule is not None:
            self.schedule.export(outfile, level, namespace_, name_='schedule', pretty_print=pretty_print)
        if self.startedAt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartedAt>%s</%sstartedAt>%s' % (namespace_, self.gds_format_datetime(self.startedAt, input_name='startedAt'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.endedAt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendedAt>%s</%sendedAt>%s' % (namespace_, self.gds_format_datetime(self.endedAt, input_name='endedAt'), namespace_, eol_))
        for outputs_ in self.outputs:
            outputs_.export(outfile, level, namespace_, name_='outputs', pretty_print=pretty_print)
        if self.scheduleResultStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscheduleResultStatus>%s</%sscheduleResultStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.scheduleResultStatus).encode(ExternalEncoding), input_name='scheduleResultStatus'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='scheduleResult'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.transactionId is not None:
            showIndent(outfile, level)
            outfile.write('transactionId=%s,\n' % quote_python(self.transactionId).encode(ExternalEncoding))
        if self.workflow is not None:
            showIndent(outfile, level)
            outfile.write('workflow=model_.workflow(\n')
            self.workflow.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.schedule is not None:
            showIndent(outfile, level)
            outfile.write('schedule=model_.schedule(\n')
            self.schedule.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startedAt is not None:
            showIndent(outfile, level)
            outfile.write('startedAt=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startedAt, input_name='startedAt'))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.endedAt is not None:
            showIndent(outfile, level)
            outfile.write('endedAt=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endedAt, input_name='endedAt'))
        showIndent(outfile, level)
        outfile.write('outputs=[\n')
        level += 1
        for outputs_ in self.outputs:
            showIndent(outfile, level)
            outfile.write('model_.providerOutput(\n')
            outputs_.exportLiteral(outfile, level, name_='providerOutput')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.scheduleResultStatus is not None:
            showIndent(outfile, level)
            outfile.write('scheduleResultStatus=%s,\n' % quote_python(self.scheduleResultStatus).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transactionId':
            transactionId_ = child_.text
            transactionId_ = self.gds_validate_string(transactionId_, node, 'transactionId')
            self.transactionId = transactionId_
        elif nodeName_ == 'workflow':
            obj_ = workflow.factory()
            obj_.build(child_)
            self.workflow = obj_
            obj_.original_tagname_ = 'workflow'
        elif nodeName_ == 'schedule':
            obj_ = schedule.factory()
            obj_.build(child_)
            self.schedule = obj_
            obj_.original_tagname_ = 'schedule'
        elif nodeName_ == 'startedAt':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.startedAt = dval_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'endedAt':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.endedAt = dval_
        elif nodeName_ == 'outputs':
            obj_ = providerOutput.factory()
            obj_.build(child_)
            self.outputs.append(obj_)
            obj_.original_tagname_ = 'outputs'
        elif nodeName_ == 'scheduleResultStatus':
            scheduleResultStatus_ = child_.text
            scheduleResultStatus_ = self.gds_validate_string(scheduleResultStatus_, node, 'scheduleResultStatus')
            self.scheduleResultStatus = scheduleResultStatus_
# end class scheduleResult


class scheduleResultPageable(abstractResultsPageable):
    subclass = None
    superclass = abstractResultsPageable
    def __init__(self, pageSize=None, totalPages=None, totalRecords=None, currentPageTotal=None, currentPage=None, entityWrapper=None):
        self.original_tagname_ = None
        super(scheduleResultPageable, self).__init__(pageSize, totalPages, totalRecords, currentPageTotal, currentPage, )
        self.entityWrapper = entityWrapper
    def factory(*args_, **kwargs_):
        if scheduleResultPageable.subclass:
            return scheduleResultPageable.subclass(*args_, **kwargs_)
        else:
            return scheduleResultPageable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entityWrapper(self): return self.entityWrapper
    def set_entityWrapper(self, entityWrapper): self.entityWrapper = entityWrapper
    def hasContent_(self):
        if (
            self.entityWrapper is not None or
            super(scheduleResultPageable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='scheduleResultPageable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleResultPageable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='scheduleResultPageable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scheduleResultPageable'):
        super(scheduleResultPageable, self).exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleResultPageable')
    def exportChildren(self, outfile, level, namespace_='', name_='scheduleResultPageable', fromsubclass_=False, pretty_print=True):
        super(scheduleResultPageable, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entityWrapper is not None:
            self.entityWrapper.export(outfile, level, namespace_, name_='entityWrapper', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scheduleResultPageable'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(scheduleResultPageable, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(scheduleResultPageable, self).exportLiteralChildren(outfile, level, name_)
        if self.entityWrapper is not None:
            showIndent(outfile, level)
            outfile.write('entityWrapper=model_.scheduleResults(\n')
            self.entityWrapper.exportLiteral(outfile, level, name_='entityWrapper')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(scheduleResultPageable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entityWrapper':
            obj_ = scheduleResults.factory()
            obj_.build(child_)
            self.entityWrapper = obj_
            obj_.original_tagname_ = 'entityWrapper'
        super(scheduleResultPageable, self).buildChildren(child_, node, nodeName_, True)
# end class scheduleResultPageable


class scheduleResults(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scheduleResults=None):
        self.original_tagname_ = None
        if scheduleResults is None:
            self.scheduleResults = []
        else:
            self.scheduleResults = scheduleResults
    def factory(*args_, **kwargs_):
        if scheduleResults.subclass:
            return scheduleResults.subclass(*args_, **kwargs_)
        else:
            return scheduleResults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduleResults(self): return self.scheduleResults
    def set_scheduleResults(self, scheduleResults): self.scheduleResults = scheduleResults
    def add_scheduleResults(self, value): self.scheduleResults.append(value)
    def insert_scheduleResults_at(self, index, value): self.scheduleResults.insert(index, value)
    def replace_scheduleResults_at(self, index, value): self.scheduleResults[index] = value
    def hasContent_(self):
        if (
            self.scheduleResults
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='scheduleResults', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleResults')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='scheduleResults', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scheduleResults'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scheduleResults', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for scheduleResults_ in self.scheduleResults:
            scheduleResults_.export(outfile, level, namespace_, name_='scheduleResults', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scheduleResults'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('scheduleResults=[\n')
        level += 1
        for scheduleResults_ in self.scheduleResults:
            showIndent(outfile, level)
            outfile.write('model_.scheduleResult(\n')
            scheduleResults_.exportLiteral(outfile, level, name_='scheduleResult')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduleResults':
            obj_ = scheduleResult.factory()
            obj_.build(child_)
            self.scheduleResults.append(obj_)
            obj_.original_tagname_ = 'scheduleResults'
# end class scheduleResults


class recurrenceRange(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, endDate=None, id=None, startDate=None):
        self.original_tagname_ = None
        if isinstance(endDate, basestring):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.id = id
        if isinstance(startDate, basestring):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
    def factory(*args_, **kwargs_):
        if recurrenceRange.subclass:
            return recurrenceRange.subclass(*args_, **kwargs_)
        else:
            return recurrenceRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def hasContent_(self):
        if (
            self.endDate is not None or
            self.id is not None or
            self.startDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recurrenceRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recurrenceRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recurrenceRange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recurrenceRange'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recurrenceRange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.endDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDate>%s</%sendDate>%s' % (namespace_, self.gds_format_datetime(self.endDate, input_name='endDate'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespace_, self.gds_format_datetime(self.startDate, input_name='startDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='recurrenceRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.endDate is not None:
            showIndent(outfile, level)
            outfile.write('endDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endDate, input_name='endDate'))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.startDate is not None:
            showIndent(outfile, level)
            outfile.write('startDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startDate, input_name='startDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'endDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.endDate = dval_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.startDate = dval_
# end class recurrenceRange


class task(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, extensiontype_=None):
        self.original_tagname_ = None
        self.enabled = enabled
        self.taskHour = taskHour
        self.description = description
        self.id = id
        self.name = name
        self.period = period
        self.recurrenceRange = recurrenceRange
        self.taskMinute = taskMinute
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if task.subclass:
            return task.subclass(*args_, **kwargs_)
        else:
            return task(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def get_taskHour(self): return self.taskHour
    def set_taskHour(self, taskHour): self.taskHour = taskHour
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_recurrenceRange(self): return self.recurrenceRange
    def set_recurrenceRange(self, recurrenceRange): self.recurrenceRange = recurrenceRange
    def get_taskMinute(self): return self.taskMinute
    def set_taskMinute(self, taskMinute): self.taskMinute = taskMinute
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.taskHour is not None or
            self.description is not None or
            self.id is not None or
            self.name is not None or
            self.period is not None or
            self.recurrenceRange is not None or
            self.taskMinute is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='task', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='task')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='task', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='task'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='task', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespace_, self.gds_format_boolean(self.enabled, input_name='enabled'), namespace_, eol_))
        if self.taskHour is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staskHour>%s</%staskHour>%s' % (namespace_, self.gds_format_integer(self.taskHour, input_name='taskHour'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_integer(self.id, input_name='id'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespace_, self.gds_format_string(quote_xml(self.period).encode(ExternalEncoding), input_name='period'), namespace_, eol_))
        if self.recurrenceRange is not None:
            self.recurrenceRange.export(outfile, level, namespace_, name_='recurrenceRange', pretty_print=pretty_print)
        if self.taskMinute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staskMinute>%s</%staskMinute>%s' % (namespace_, self.gds_format_integer(self.taskMinute, input_name='taskMinute'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='task'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=%s,\n' % self.enabled)
        if self.taskHour is not None:
            showIndent(outfile, level)
            outfile.write('taskHour=%d,\n' % self.taskHour)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % self.id)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.period is not None:
            showIndent(outfile, level)
            outfile.write('period=%s,\n' % quote_python(self.period).encode(ExternalEncoding))
        if self.recurrenceRange is not None:
            showIndent(outfile, level)
            outfile.write('recurrenceRange=model_.recurrenceRange(\n')
            self.recurrenceRange.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.taskMinute is not None:
            showIndent(outfile, level)
            outfile.write('taskMinute=%d,\n' % self.taskMinute)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'taskHour':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taskHour')
            self.taskHour = ival_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'period':
            period_ = child_.text
            period_ = self.gds_validate_string(period_, node, 'period')
            self.period = period_
        elif nodeName_ == 'recurrenceRange':
            obj_ = recurrenceRange.factory()
            obj_.build(child_)
            self.recurrenceRange = obj_
            obj_.original_tagname_ = 'recurrenceRange'
        elif nodeName_ == 'taskMinute':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'taskMinute')
            self.taskMinute = ival_
# end class task


class appInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None):
        self.original_tagname_ = None
        self.name = name
        self.version = version
    def factory(*args_, **kwargs_):
        if appInfo.subclass:
            return appInfo.subclass(*args_, **kwargs_)
        else:
            return appInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.name is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='appInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='appInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='appInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='appInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='appInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_string(quote_xml(self.version).encode(ExternalEncoding), input_name='version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='appInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
# end class appInfo


class simpleTask(task):
    subclass = None
    superclass = task
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, extensiontype_=None):
        self.original_tagname_ = None
        super(simpleTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if simpleTask.subclass:
            return simpleTask.subclass(*args_, **kwargs_)
        else:
            return simpleTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(simpleTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='simpleTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simpleTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='simpleTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simpleTask'):
        super(simpleTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='simpleTask')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='simpleTask', fromsubclass_=False, pretty_print=True):
        super(simpleTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='simpleTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(simpleTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(simpleTask, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(simpleTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(simpleTask, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class simpleTask


class secondsTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, reoccurInSeconds=None):
        self.original_tagname_ = None
        super(secondsTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.reoccurInSeconds = reoccurInSeconds
    def factory(*args_, **kwargs_):
        if secondsTask.subclass:
            return secondsTask.subclass(*args_, **kwargs_)
        else:
            return secondsTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reoccurInSeconds(self): return self.reoccurInSeconds
    def set_reoccurInSeconds(self, reoccurInSeconds): self.reoccurInSeconds = reoccurInSeconds
    def hasContent_(self):
        if (
            self.reoccurInSeconds is not None or
            super(secondsTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='secondsTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='secondsTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='secondsTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='secondsTask'):
        super(secondsTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='secondsTask')
    def exportChildren(self, outfile, level, namespace_='', name_='secondsTask', fromsubclass_=False, pretty_print=True):
        super(secondsTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reoccurInSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreoccurInSeconds>%s</%sreoccurInSeconds>%s' % (namespace_, self.gds_format_integer(self.reoccurInSeconds, input_name='reoccurInSeconds'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='secondsTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(secondsTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(secondsTask, self).exportLiteralChildren(outfile, level, name_)
        if self.reoccurInSeconds is not None:
            showIndent(outfile, level)
            outfile.write('reoccurInSeconds=%d,\n' % self.reoccurInSeconds)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(secondsTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reoccurInSeconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reoccurInSeconds')
            self.reoccurInSeconds = ival_
        super(secondsTask, self).buildChildren(child_, node, nodeName_, True)
# end class secondsTask


class runOnceTask(task):
    subclass = None
    superclass = task
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None):
        self.original_tagname_ = None
        super(runOnceTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
    def factory(*args_, **kwargs_):
        if runOnceTask.subclass:
            return runOnceTask.subclass(*args_, **kwargs_)
        else:
            return runOnceTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(runOnceTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='runOnceTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='runOnceTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='runOnceTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='runOnceTask'):
        super(runOnceTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='runOnceTask')
    def exportChildren(self, outfile, level, namespace_='', name_='runOnceTask', fromsubclass_=False, pretty_print=True):
        super(runOnceTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='runOnceTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(runOnceTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(runOnceTask, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(runOnceTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(runOnceTask, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class runOnceTask


class monthlyTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, dayOfMonth=None, dayOfWeek=None, recurrence=None):
        self.original_tagname_ = None
        super(monthlyTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.dayOfMonth = dayOfMonth
        self.dayOfWeek = dayOfWeek
        self.recurrence = recurrence
    def factory(*args_, **kwargs_):
        if monthlyTask.subclass:
            return monthlyTask.subclass(*args_, **kwargs_)
        else:
            return monthlyTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayOfMonth(self): return self.dayOfMonth
    def set_dayOfMonth(self, dayOfMonth): self.dayOfMonth = dayOfMonth
    def get_dayOfWeek(self): return self.dayOfWeek
    def set_dayOfWeek(self, dayOfWeek): self.dayOfWeek = dayOfWeek
    def get_recurrence(self): return self.recurrence
    def set_recurrence(self, recurrence): self.recurrence = recurrence
    def hasContent_(self):
        if (
            self.dayOfMonth is not None or
            self.dayOfWeek is not None or
            self.recurrence is not None or
            super(monthlyTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='monthlyTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monthlyTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='monthlyTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='monthlyTask'):
        super(monthlyTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='monthlyTask')
    def exportChildren(self, outfile, level, namespace_='', name_='monthlyTask', fromsubclass_=False, pretty_print=True):
        super(monthlyTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayOfMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfMonth>%s</%sdayOfMonth>%s' % (namespace_, self.gds_format_integer(self.dayOfMonth, input_name='dayOfMonth'), namespace_, eol_))
        if self.dayOfWeek is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfWeek>%s</%sdayOfWeek>%s' % (namespace_, self.gds_format_integer(self.dayOfWeek, input_name='dayOfWeek'), namespace_, eol_))
        if self.recurrence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srecurrence>%s</%srecurrence>%s' % (namespace_, self.gds_format_string(quote_xml(self.recurrence).encode(ExternalEncoding), input_name='recurrence'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='monthlyTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(monthlyTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(monthlyTask, self).exportLiteralChildren(outfile, level, name_)
        if self.dayOfMonth is not None:
            showIndent(outfile, level)
            outfile.write('dayOfMonth=%d,\n' % self.dayOfMonth)
        if self.dayOfWeek is not None:
            showIndent(outfile, level)
            outfile.write('dayOfWeek=%d,\n' % self.dayOfWeek)
        if self.recurrence is not None:
            showIndent(outfile, level)
            outfile.write('recurrence=%s,\n' % quote_python(self.recurrence).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(monthlyTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayOfMonth':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayOfMonth')
            self.dayOfMonth = ival_
        elif nodeName_ == 'dayOfWeek':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayOfWeek')
            self.dayOfWeek = ival_
        elif nodeName_ == 'recurrence':
            recurrence_ = child_.text
            recurrence_ = self.gds_validate_string(recurrence_, node, 'recurrence')
            self.recurrence = recurrence_
        super(monthlyTask, self).buildChildren(child_, node, nodeName_, True)
# end class monthlyTask


class minutesTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, reoccurInMinutes=None):
        self.original_tagname_ = None
        super(minutesTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.reoccurInMinutes = reoccurInMinutes
    def factory(*args_, **kwargs_):
        if minutesTask.subclass:
            return minutesTask.subclass(*args_, **kwargs_)
        else:
            return minutesTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reoccurInMinutes(self): return self.reoccurInMinutes
    def set_reoccurInMinutes(self, reoccurInMinutes): self.reoccurInMinutes = reoccurInMinutes
    def hasContent_(self):
        if (
            self.reoccurInMinutes is not None or
            super(minutesTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='minutesTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='minutesTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='minutesTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='minutesTask'):
        super(minutesTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='minutesTask')
    def exportChildren(self, outfile, level, namespace_='', name_='minutesTask', fromsubclass_=False, pretty_print=True):
        super(minutesTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reoccurInMinutes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreoccurInMinutes>%s</%sreoccurInMinutes>%s' % (namespace_, self.gds_format_integer(self.reoccurInMinutes, input_name='reoccurInMinutes'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='minutesTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(minutesTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(minutesTask, self).exportLiteralChildren(outfile, level, name_)
        if self.reoccurInMinutes is not None:
            showIndent(outfile, level)
            outfile.write('reoccurInMinutes=%d,\n' % self.reoccurInMinutes)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(minutesTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reoccurInMinutes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reoccurInMinutes')
            self.reoccurInMinutes = ival_
        super(minutesTask, self).buildChildren(child_, node, nodeName_, True)
# end class minutesTask


class hourlyTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, reoccurInHours=None):
        self.original_tagname_ = None
        super(hourlyTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.reoccurInHours = reoccurInHours
    def factory(*args_, **kwargs_):
        if hourlyTask.subclass:
            return hourlyTask.subclass(*args_, **kwargs_)
        else:
            return hourlyTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reoccurInHours(self): return self.reoccurInHours
    def set_reoccurInHours(self, reoccurInHours): self.reoccurInHours = reoccurInHours
    def hasContent_(self):
        if (
            self.reoccurInHours is not None or
            super(hourlyTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='hourlyTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hourlyTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='hourlyTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='hourlyTask'):
        super(hourlyTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='hourlyTask')
    def exportChildren(self, outfile, level, namespace_='', name_='hourlyTask', fromsubclass_=False, pretty_print=True):
        super(hourlyTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reoccurInHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreoccurInHours>%s</%sreoccurInHours>%s' % (namespace_, self.gds_format_integer(self.reoccurInHours, input_name='reoccurInHours'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='hourlyTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(hourlyTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(hourlyTask, self).exportLiteralChildren(outfile, level, name_)
        if self.reoccurInHours is not None:
            showIndent(outfile, level)
            outfile.write('reoccurInHours=%d,\n' % self.reoccurInHours)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(hourlyTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reoccurInHours':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reoccurInHours')
            self.reoccurInHours = ival_
        super(hourlyTask, self).buildChildren(child_, node, nodeName_, True)
# end class hourlyTask


class dailyTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, reoccurInDays=None, everyWeekDays=None):
        self.original_tagname_ = None
        super(dailyTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.reoccurInDays = reoccurInDays
        self.everyWeekDays = everyWeekDays
    def factory(*args_, **kwargs_):
        if dailyTask.subclass:
            return dailyTask.subclass(*args_, **kwargs_)
        else:
            return dailyTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reoccurInDays(self): return self.reoccurInDays
    def set_reoccurInDays(self, reoccurInDays): self.reoccurInDays = reoccurInDays
    def get_everyWeekDays(self): return self.everyWeekDays
    def set_everyWeekDays(self, everyWeekDays): self.everyWeekDays = everyWeekDays
    def hasContent_(self):
        if (
            self.reoccurInDays is not None or
            self.everyWeekDays is not None or
            super(dailyTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dailyTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dailyTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dailyTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dailyTask'):
        super(dailyTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dailyTask')
    def exportChildren(self, outfile, level, namespace_='', name_='dailyTask', fromsubclass_=False, pretty_print=True):
        super(dailyTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reoccurInDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreoccurInDays>%s</%sreoccurInDays>%s' % (namespace_, self.gds_format_integer(self.reoccurInDays, input_name='reoccurInDays'), namespace_, eol_))
        if self.everyWeekDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyWeekDays>%s</%severyWeekDays>%s' % (namespace_, self.gds_format_boolean(self.everyWeekDays, input_name='everyWeekDays'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='dailyTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(dailyTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dailyTask, self).exportLiteralChildren(outfile, level, name_)
        if self.reoccurInDays is not None:
            showIndent(outfile, level)
            outfile.write('reoccurInDays=%d,\n' % self.reoccurInDays)
        if self.everyWeekDays is not None:
            showIndent(outfile, level)
            outfile.write('everyWeekDays=%s,\n' % self.everyWeekDays)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(dailyTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reoccurInDays':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reoccurInDays')
            self.reoccurInDays = ival_
        elif nodeName_ == 'everyWeekDays':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'everyWeekDays')
            self.everyWeekDays = ival_
        super(dailyTask, self).buildChildren(child_, node, nodeName_, True)
# end class dailyTask


class cronTask(task):
    subclass = None
    superclass = task
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, cronExpression=None):
        self.original_tagname_ = None
        super(cronTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        self.cronExpression = cronExpression
    def factory(*args_, **kwargs_):
        if cronTask.subclass:
            return cronTask.subclass(*args_, **kwargs_)
        else:
            return cronTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cronExpression(self): return self.cronExpression
    def set_cronExpression(self, cronExpression): self.cronExpression = cronExpression
    def hasContent_(self):
        if (
            self.cronExpression is not None or
            super(cronTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cronTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cronTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cronTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cronTask'):
        super(cronTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cronTask')
    def exportChildren(self, outfile, level, namespace_='', name_='cronTask', fromsubclass_=False, pretty_print=True):
        super(cronTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cronExpression is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scronExpression>%s</%scronExpression>%s' % (namespace_, self.gds_format_string(quote_xml(self.cronExpression).encode(ExternalEncoding), input_name='cronExpression'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='cronTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cronTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cronTask, self).exportLiteralChildren(outfile, level, name_)
        if self.cronExpression is not None:
            showIndent(outfile, level)
            outfile.write('cronExpression=%s,\n' % quote_python(self.cronExpression).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cronTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cronExpression':
            cronExpression_ = child_.text
            cronExpression_ = self.gds_validate_string(cronExpression_, node, 'cronExpression')
            self.cronExpression = cronExpression_
        super(cronTask, self).buildChildren(child_, node, nodeName_, True)
# end class cronTask


class scheduleTag(tag):
    subclass = None
    superclass = tag
    def __init__(self, name=None, id=None):
        self.original_tagname_ = None
        super(scheduleTag, self).__init__(name, id, )
    def factory(*args_, **kwargs_):
        if scheduleTag.subclass:
            return scheduleTag.subclass(*args_, **kwargs_)
        else:
            return scheduleTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(scheduleTag, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='scheduleTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='scheduleTag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scheduleTag'):
        super(scheduleTag, self).exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleTag')
    def exportChildren(self, outfile, level, namespace_='', name_='scheduleTag', fromsubclass_=False, pretty_print=True):
        super(scheduleTag, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='scheduleTag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(scheduleTag, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(scheduleTag, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(scheduleTag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(scheduleTag, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class scheduleTag


class providerTag(tag):
    subclass = None
    superclass = tag
    def __init__(self, name=None, id=None):
        self.original_tagname_ = None
        super(providerTag, self).__init__(name, id, )
    def factory(*args_, **kwargs_):
        if providerTag.subclass:
            return providerTag.subclass(*args_, **kwargs_)
        else:
            return providerTag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(providerTag, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='providerTag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='providerTag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='providerTag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='providerTag'):
        super(providerTag, self).exportAttributes(outfile, level, already_processed, namespace_, name_='providerTag')
    def exportChildren(self, outfile, level, namespace_='', name_='providerTag', fromsubclass_=False, pretty_print=True):
        super(providerTag, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='providerTag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(providerTag, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(providerTag, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(providerTag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(providerTag, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class providerTag


class weeklyTask(simpleTask):
    subclass = None
    superclass = simpleTask
    def __init__(self, enabled=None, taskHour=None, description=None, id=None, name=None, period=None, recurrenceRange=None, taskMinute=None, daysOfWeek=None):
        self.original_tagname_ = None
        super(weeklyTask, self).__init__(enabled, taskHour, description, id, name, period, recurrenceRange, taskMinute, )
        if daysOfWeek is None:
            self.daysOfWeek = []
        else:
            self.daysOfWeek = daysOfWeek
    def factory(*args_, **kwargs_):
        if weeklyTask.subclass:
            return weeklyTask.subclass(*args_, **kwargs_)
        else:
            return weeklyTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daysOfWeek(self): return self.daysOfWeek
    def set_daysOfWeek(self, daysOfWeek): self.daysOfWeek = daysOfWeek
    def add_daysOfWeek(self, value): self.daysOfWeek.append(value)
    def insert_daysOfWeek_at(self, index, value): self.daysOfWeek.insert(index, value)
    def replace_daysOfWeek_at(self, index, value): self.daysOfWeek[index] = value
    def hasContent_(self):
        if (
            self.daysOfWeek or
            super(weeklyTask, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='weeklyTask', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weeklyTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='weeklyTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='weeklyTask'):
        super(weeklyTask, self).exportAttributes(outfile, level, already_processed, namespace_, name_='weeklyTask')
    def exportChildren(self, outfile, level, namespace_='', name_='weeklyTask', fromsubclass_=False, pretty_print=True):
        super(weeklyTask, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for daysOfWeek_ in self.daysOfWeek:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdaysOfWeek>%s</%sdaysOfWeek>%s' % (namespace_, self.gds_format_integer(daysOfWeek_, input_name='daysOfWeek'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='weeklyTask'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(weeklyTask, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(weeklyTask, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('daysOfWeek=[\n')
        level += 1
        for daysOfWeek_ in self.daysOfWeek:
            showIndent(outfile, level)
            outfile.write('%d,\n' % daysOfWeek_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(weeklyTask, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'daysOfWeek':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'daysOfWeek')
            self.daysOfWeek.append(ival_)
        super(weeklyTask, self).buildChildren(child_, node, nodeName_, True)
# end class weeklyTask


GDSClassesMapping = {
    'inputFields': providerInputField,
    'providerOutputs': providerOutput,
    'tasks': task,
    'tags': scheduleTag,
    'workflowSteps': workflowStep,
    'pipes': providerInput,
    'schedules': schedule,
    'outputField': providerOutputField,
    'outputFields': providerOutputField,
    'onFailureWorkflow': workflow,
    'onSuccessWorkflow': workflow,
    'entityWrapper': scheduleResults,
    'input': providerInput,
    'output': providerOutput,
    'workflows': workflow,
    'scheduleResults': scheduleResult,
    'outputs': providerOutput,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'abstractResultsPageable'
        rootClass = abstractResultsPageable
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'abstractResultsPageable'
        rootClass = abstractResultsPageable
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'abstractResultsPageable'
        rootClass = abstractResultsPageable
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'abstractResultsPageable'
        rootClass = abstractResultsPageable
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from integrads import *\n\n')
        sys.stdout.write('import integrads as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "abstractResultsPageable",
    "appInfo",
    "configuration",
    "configurations",
    "cronTask",
    "dailyTask",
    "entityPageRequest",
    "hourlyTask",
    "license",
    "minutesTask",
    "monthlyTask",
    "provider",
    "providerAction",
    "providerActions",
    "providerInput",
    "providerInputField",
    "providerOutput",
    "providerOutputField",
    "providerOutputs",
    "providerTag",
    "providers",
    "recurrenceRange",
    "runOnceTask",
    "schedule",
    "scheduleResult",
    "scheduleResultPageable",
    "scheduleResults",
    "scheduleTag",
    "schedules",
    "secondsTask",
    "simpleTask",
    "tag",
    "tags",
    "task",
    "weeklyTask",
    "workflow",
    "workflowAction",
    "workflowActionSearch",
    "workflowActionTag",
    "workflowActions",
    "workflowStep",
    "workflowTag",
    "workflowTransaction",
    "workflows"
]
